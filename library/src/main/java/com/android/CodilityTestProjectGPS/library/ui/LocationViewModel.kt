
package com.android.CodilityTestProjectGPS.library.ui

import android.annotation.SuppressLint
import android.app.Application
import android.content.Context
import android.content.SharedPreferences
import android.location.Location
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData

import androidx.lifecycle.MutableLiveData

import androidx.lifecycle.viewModelScope

import com.android.CodilityTestProjectGPS.*
import com.android.CodilityTestProjectGPS.library.data.GecoderResponse
import com.android.CodilityTestProjectGPS.library.data.LocationRepository
import com.android.CodilityTestProjectGPS.library.data.NetworkResult
import com.android.CodilityTestProjectGPS.library.util.PreferenceUtil
//import com.android.CodilityTestProject.library.
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * View model that holds GNSS signal information
 */

@ExperimentalCoroutinesApi
@HiltViewModel
class LocationViewModel @Inject constructor(
    context: Context,
    application: Application,
    private val repository: LocationRepository,
    prefs: SharedPreferences
) : AndroidViewModel(application) {
    //
    // Flow for getting latitude and longitude
    //
    private var locationFlow: Job? = null

    private val _GeocodingResponse: MutableLiveData<NetworkResult<GecoderResponse>> = MutableLiveData()

    val responseType : MutableLiveData<NetworkResult<GecoderResponse>> = MutableLiveData()

    val geoCodingResponse : MutableLiveData<GecoderResponse> = MutableLiveData()

    fun getReverseGeocoding(latitude: Double, longitude: Double) = viewModelScope.launch {
        repository.getGecodingResponse(latitude , longitude).collect{ values ->
//            Log.d("LocationViewModel :", values.data!!.display_name)
            when (values) {
                is NetworkResult.Success -> {
                    values.data?.let {
                        Log.d("LocationViewModel :", values.data.toString())
                        geoCodingResponse.postValue(it)
                    }
                }

                is NetworkResult.Error -> {
                    val errorMessage = values.message ?: "An Error Occurred with geocoding api!!"
                    responseType.value = NetworkResult.Error(errorMessage)
                }

                is NetworkResult.Loading -> {
                    responseType.value = NetworkResult.Loading()
                }
            }
        }
    }
    private val _location = MutableLiveData<Location>()
    val location: LiveData<Location> = _location


    private var started = false

    // Preference listener that will cancel the above flows when the user turns off tracking via UI
    private val trackingListener: SharedPreferences.OnSharedPreferenceChangeListener =
        PreferenceUtil.newStopTrackingListener({setStarted(context, false, prefs)}, prefs)

    init {
        viewModelScope.launch {
            observeLocationUpdateStates(context, prefs)
            prefs.registerOnSharedPreferenceChangeListener(trackingListener)
        }
    }

    @ExperimentalCoroutinesApi
    private fun observeLocationUpdateStates(context: Context, prefs: SharedPreferences) {
        repository.receivingLocationUpdates
            .onEach {
                setStarted(context, it, prefs)
            }
            .launchIn(viewModelScope)
    }

    @ExperimentalCoroutinesApi
    private fun observeLocationFlow() {
        if (locationFlow?.isActive == true) {
            // If we're already observing updates, don't register again
            return
        }
        // Observe locations via Flow as they are generated by the repository
        locationFlow = repository.getLocations()
            .onEach {
                //Log.d(TAG, "SignalInfoViewModel location: ${it.toNotificationTitle()}")
                _location.value = it
            }
            .launchIn(viewModelScope)
    }


    @ExperimentalCoroutinesApi
    @SuppressLint("NotifyDataSetChanged")
    private fun setStarted(context: Context, started: Boolean, prefs: SharedPreferences) {
        if (started == this.started) {
            // State hasn't changed - no op and return
            return
        }
        if (started) {
            // Activity or service is observing updates, so observe here too
            observeLocationFlow()
        } else {
            // Cancel updates (Note that these are canceled via trackingListener preference listener
            // in the case where updates are stopped from the Activity UI switch)
            cancelFlows()

            // Reset views
            reset()
        }
        this.started = started
    }

    private fun cancelFlows() {
        locationFlow?.cancel()
    }



    fun reset() {
        _location.value = Location("reset")
    }

    /**
     * Called when the lifecycle of the observer is ended
     */
    override fun onCleared() {
        super.onCleared()
        reset()
    }
}